---
title: "flowFun"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{flowFun}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

# Installation
```{r, eval = FALSE}
install.packages("devtools", dependencies = TRUE, build_vignettes = TRUE)
devtools::install_github("00berst33/flowFun")
```

# Reading in Data

Blob Cytometry data often contains millions of cells, so to facilitate fast and efficient manipulation of these large datasets, this package implements the `cytoset` and `cytoframe` data structures from the `flowWorkspace` package. These are analogous to the more well known `flowSet` and `flowFrame` structures, but store the data in a more compact format that is easier for a computer to handle. To learn more, try seeing the documentation for `flowWorkspace`, or entering `vignette(package="flowWorkspace", "flowWorkspace-Introduction")` into the RStudio console. 

These data structures are also advantageous because they may easily be converted back to a `flowFrame` or `flowSet`, which are used in many other useful packages in Bioconductor. This also makes the package more flexible, as although it focuses on the use of the FlowSOM package for clustering, the package could easily be expanded to work with any other clustering algorithm the user may prefer.

The code below demonstrates how data may be loaded in as the appropriate format. 

`getTableFromFCS()` allows the user to read .fcs files directly into a data table, either by specifying a list of directories containing relevant files, or by providing a list with the relative or absolute filepaths of each file of interest. The expression data for each sample are joined by row, and two columns are joined to the left of the table: `.id` and `cell_id`.

By default, all cells are sampled from each .fcs file of interest, but the parameter `num_cells` may be specified to select 

```{r load-data}
library(flowCore)
library(tidytable)
library(flowFun)
library(flowWorkspace)

# Specify path to .fcs file
# file <- system.file("extdata", "aggregate.fcs", package = "flowFun") # make gatingSet
# Read in as tidytable
# table <- getTableFromFCS(file, num_cells = 1000)

# Specify path to .fcs file
file <- system.file("extdata", "raw_flowset.rds", package="flowFun")
fs <- readRDS(file)
gs1 <- GatingSet(fs)
# Load gs on disk
# NOTE: if you would like to discard the edits you have made to the current
# GatingSet object, reload the backup from disk an make another deep copy, then
# proceed.
# gs1 <- flowWorkspace::load_gs(dir)
# gs1 <- flowWorkspace::gs_clone(gs1)

gs1
```

The following is a snippet of the resulting table:

```{r print-table, fig.align='center', echo=FALSE, include=FALSE, eval=FALSE} 
table$.id <- basename(table$.id)

table %>% 
  tidytable::select(tidytable::all_of(1:10)) %>%
  tidytable::slice_head(5) %>%
  data.frame() %>%
  knitr::kable(
    format = "html",
    align = "c",
    linesep = "",
    )
```

# Preprocessing

Once setup files have been cleaned and a compensation matrix has been generated, the next step is to preprocess the raw data. In order, the steps this pipeline implements are as follows:

1. Removing margin events (i.e. values that fall outside the range the cytometer should be able to pick up).
2. Removing doublets.
3. Removing debris.
4. Compensating the data.
5. Transforming the data.
6. Removing dead cells.
      
Each these steps, other than acquiring a compensation matrix, may be left entirely automated if desired. However, oftentimes parameter tuning is necessary for optimal results. Furthermore, some samples' data may be distributed in a way that is markedly different from the average, making automated gating ineffective. For this reason the user also has the option of manually drawing gates, by either simply using the same one for each sample, or retroactively selecting samples which the automated gating performed poorly for and re-drawing gates as necessary. Although it is implemented, it is recommended to avoid manual gating where possible. Doing so improves the objectivity and reproducibility of the analysis.

This pipeline primarily uses the package `openCyto` to implement preprocessing. This package can create an automated gating pipeline using a `gatingTemplate`, which is specified by a user-created spread sheet with 10 columns: `alias`, `pop`, `parent`, `dims`, `gating_method`, `gating_args`, `collapseDataForGating`, `groupBy`, `preprocessing_method`, and `preprocessing_args`. To see the details on how the values for these columns should be entered, see the `openCytoVignette` in the `openCyto` package. `flowFun` contains a default `gatingTemplate` that will draw the basic gates, so most users only need to understand how to appropriately edit this file, and not concern themselves with making one from scratch.

However, the user will have to supply a compensation matrix and choose whatever transformation they would like to apply. Also, if your panel includes a viability stain, it is necessary to specify the corresponding channel, so that dead cells may be gated out accurately.

The code below reads in the default .csv file and prints its contents, then creates a corresponding `gatingTemplate`.

```{r gating-template}
library(flowDensity)
library(openCyto)

# Specify L/D stain
ld_stain <- "BUV496-A"

# Gating template csv
# Try editing the CSV yourself if you would like to add more gates.
# For explanations on how to do this, try running each command in the R console:
#   `vignette(package="openCyto", "openCytoVignette")`
#   `vignette(package="openCyto", "HowToAutoGating")`
# They each will take you to page that shows you how this file should look, and
# what it can be used for.
file <- system.file("extdata", "gating_template.csv", package = "flowFun")
gt <- gatingTemplate(file)

# Print template .csv
read.csv(file)[-1]
```

The first notable item in this file that a user may want to edit is `groupBy`; to apply the same gate to all samples, this value should be equivalent to the number of samples in your experiment. In this example, we have 6 samples. 

It may also be helpful to edit `gating_args`. Again, more details can be found in the `openCyto` vignettes, but it is most relevant to know that the parameter `gate_range` restricts the range of the automated gate being applied at that step. So, for row 2, whose alias is `nonDebris` (i.e. where a gate will be constructed around non-debris events), we have `gate_range=c(15000,80000)`, therefore the gate cannot be placed outside of that range for FSC-A.

Also, if the user does not have a live/dead stain, the fourth row with alias `live` should be removed.

Below, the compensation matrix is read in, the transformation applied, and the automated gating applied and visualized.

```{r preprocessing, fig.height=5, fig.width=7}
# Compensation matrix csv
comp_mat <- system.file("extdata", "compensation_matrix.csv", package = "flowFun")
comp_mat <- read.csv(comp_mat, check.names = FALSE)


# Visualize current gating scheme
plot(gt)

# Compensate
# !!! Note: The column names of your compensation matrix must match those
#     found in your GatingSet.
#   Check that that is the case here:
colnames(comp_mat)
colnames(gs1)

compensate(gs1, comp_mat)


# Transform
trans <- flowCore::estimateLogicle(gs1[[1]], channels = colnames(comp_mat))
flowCore::transform(gs1, trans)


# Apply gating scheme
gt_gating(gt, gs1)


## Check one gate for each sample
# nonDebris gate
plotAllSamples(gs1, "FSC-A", "SSC-A", "nonMargins", "nonDebris")

# singlets gate
plotAllSamples(gs1, "FSC-A", "FSC-H", "nonDebris", "singlets")

# live cell gate
plotAllSamples(gs1, "BUV496-A", "FSC-A", "singlets", "live")
```

Here we see that the gates for dead cells and doublets are a bit loose for this sample. As an easy fix, we may adjust and draw a simple manual gate. This can be done by calling the function `editGateManual()`, which brings up an R Shiny window where the user may draw a new boundary, rectangle, ellipsoid, or polygon gate on the sample of interest. The data in the underlying `GatingSet` is edited accordingly. 

```{r manual-fix, fig.height=5, fig.width=7, fig.align='default'} 
##### Redraw gates manually, if desired
### For one sample
# Check gate before
autoplot(gs1[[7]])

# Redraw gate
editGateManual(gs1,
               node = "nonDebris",
               dims = c("FSC-A", "SSC-A"),
               sample_ids = 7)

# Check gate after
autoplot(gs1[[7]])

### For a subset of samples
# Redraw gate
editGateManual(gs1,
               node = "singlets",
               # dims = c("FSC-A", "FSC-H"), # if `dims` isn't specified, the dimensions used in original gate are used
               ref_sample = 25,
               sample_ids = 23:46) # sample_ids may also be a vector of sample indices/names to apply the new gate to

# singlets gate after
plotAllSamples(gs1, "FSC-A", "FSC-H", "nonDebris", "singlets")
# may also plot a subset of the GatingSet, for example:
plotAllSamples(gs1[23:46], "FSC-A", "FSC-H", "nonDebris", "singlets")

### For all samples
editGateManual(gs1,
               node = "live",
               dims = c("BUV496-A", "FSC-A"),
               ref_sample = 42) # sample to draw gate on; applied to all other samples when no `sample_ids` given

# live cell gate after
plotAllSamples(gs1, "BUV496-A", "FSC-A", "singlets", "live")

```

Once preprocessing results appear satisfactory, the user can either export results to FlowJo using the `CytoML` package (note: this requires Docker to be installed) or continue with this pipeline to cluster data.

# Clustering

This package is compatible with various clustering algorithms, but was designed specifically with FlowSOM in mind due to its fast runtime and tools for data visualization. Therefore, much focus will be given to FlowSOM in the following section.

The strategy for identifying cell type populations outlined by this workflow is not entirely automated, and instead uses a human-in-the-loop approach. Such an approach aims to reduce the burden of analyzing such a large volume of data, while still incorporating expert knowledge to ensure that results are biologically meaningful. To accomplish this, the data is initially overclustered. The expert then examines the result of the clustering through various relevant plots, taking into account not only marker expression but also cluster sizes and mathematical distance, and uses their best judgement to merge clusters until an appropriate final clustering has been reached and labelled. 

It is also necessary for the user to specify which markers are to be used for clustering. There are a few considerations to account for when selecting these, the most important being that it is highly recommended that any markers the user intends to test for differential expression are NOT used for clustering. There is a number of reasons for this, but in short, it generally makes little sense to test for differential expression of a marker in a cluster when the cluster is defined by high or low expression of said marker (i.e. testing for differential expression of CD8 in CD8 T cells). Furthermore, parameters like side and forward scatter should not be included, and if a viability stain was used, it should also be excluded.

Below, the preprocessed data from earlier is clustered using the FlowSOM algorithm via the function `flowSOMWrapper()`. This outputs the same table that is given to it, but with the columns `Metacluster` and `Cluster` joined to the right, giving the results of the clustering. Specifying a seed is optional, but strongly recommended for the sake of reproducibility.

``` {r flowsom-clustering}
# Read in table
prepr_table <- system.file("extdata", "prep_table.rds", package = "flowFun")
prepr_table <- readRDS(prepr_table)

# Define markers/columns to use for clustering
cols_to_cluster <- c(12, 14:16, 18, 20:25, 27:34, 36)

# Perform clustering
fsom_dt <- flowSOMWrapper(prepr_table,
                          cols_to_cluster = cols_to_cluster,
                          num_clus = 25,
                          xdim = 12,
                          ydim = 12,
                          seed = 42)

```

```{r print-fsom-table, echo=FALSE} 
fsom_dt %>% 
  tidytable::select(tidytable::all_of(c("cell_id", "Metacluster", "Cluster"))) %>%
  tidytable::slice_head(5) %>%
  data.frame() %>%
  knitr::kable(
    format = "html",
    align = "c",
    linesep = "",
    )
```

A number of different plots may be generated by this package to aid the user in merging metaclusters, but the arguably the most important are heatmaps and dimension reduction plots. Below, a heatmap of MFIs by metacluster is generated. 

```{r first-heatmap, fig.height=5, fig.width=6, fig.align='center'}
# Generate heatmap
plotMetaclusterMFIs(fsom_dt)
```

This heatmap is what the user should be using as their main reference when merging metaclusters. The dendrogram on the left-hand side, which displays a hierarchal clustering of the metaclusters, is of particular interest, and this hierarchy may be followed to perform the clustering. However, this dendrogram should not be followed blindly. First, the metaclusters that are determined to be similar by the clustering may not be of biological interest; some cell type markers may be of greater significance than others, and this is something that the clustering does not take into account. Second, dendrograms may be created with different linkage methods (single-linkage, average-linkage, centroid-linkage, etc.), and these different methods may result in slightly different hierarchies. This is not to say that the dendrogram is useless, only that it has its limitations.

The user should also consider cluster size when merging. If a metacluster is rather small, and differs from its neighboring clusters in irrelevant markers, then it is reasonable to merge it. However, if the metacluster is small but distinct in markers of interest, it may be left unmerged. 

Finally, if a metacluster does not represent any particular cell type of interest, it may be dropped from the analysis entirely. For example, depending on how strict you were with your gating, there may be some debris remaining in your preprocessed data. The clustering algorithm will likely cluster these together, and you may decide to exclude them from further analysis.

To further aid the decision making process, a UMAP colored by metacluster is generated below. 

```{r umap, fig.height=5, fig.width=6, fig.align='center'}
# Generate UMAP
plotUMAP(fsom_dt, num_cells = 5000, seed = 42)

```

This plot is most useful to check metaclusters' relative sizes, and how similar they are to one another. The closer clusters (and cells) are to each other, the more similar they are to each other. However, the opposite is not necessarily true.

By examining these plots, it starts to become clear which metaclusters are more similar to one another, and what their phenotype may be. For example, we see that metaclusters 1, 2, and 9 are all closely linked by the dendrogram in the heatmap, and are rather close to one another in the UMAP. They all have a high expression of the markers CD3 and CD8, but differ noticeably in markers PD1, CCR7, and CD45RA. It seems that these metaclusters are each a subset of CD8 T cells, and it is reasonable to merge them. Depending on the question being investigated, the user may wish to instead keep them separate, and perhaps specify exhausted and non-exhausted CD8 T cells, which could also be reasonable. 

It should be noted that if a user does desire to look at a particular cell type in greater resolution, this workflow allows for backgating on and reclustering cells belonging to a particular metacluster; therefore identifying every sub-population of interest is not necessary at this step. For now, this example will find an initial low-resolution clustering.

The function `editTableMetaclusters()` can be used to merge and rename metaclusters. A new column, `Meta_original`, is added to the given table, specifying the metaclusters that were found when the clustering algorithm was first called. The existing `Metaclusters` column is edited to contain the new assignments. 

```{r first-merge}
# Merge metaclusters
fsom_dt <- editTableMetaclusters(fsom_dt, 
                                 new_labels = c("9" = "1",
                                                "2" = "1",
                                                "8" = "4",
                                                "23" = "15",
                                                "21" = "15",
                                                "20" = "15",
                                                "22" = "15",
                                                "7" = "6"))

```

```{r first-merge-alt, include=FALSE, eval=FALSE}
# Merge metaclusters
fsom <- readRDS("vignettes/test_fsom.rds")
fsom <- FlowSOM::UpdateMetaclusters(fsom, 
                                    newLabels = c("9" = "1",
                                                  "2" = "1",
                                                  "8" = "4",
                                                  "23" = "15",
                                                  "21" = "15",
                                                  "20" = "15",
                                                  "22" = "15",
                                                  "7" = "6"))

```

```{r print-fsom-table-merge1, echo=FALSE} 
fsom_dt %>% 
  tidytable::select(tidytable::all_of(c("cell_id", "Meta_original", "Metacluster", "Cluster"))) %>%
  tidytable::slice_head(5) %>%
  data.frame() %>%
  knitr::kable(
    format = "html",
    align = "c",
    linesep = "",
    )
```

A new heatmap may be generated to reflect the new clustering, and help decide whether any further merging should be performed.

```{r second-plots, fig.height=5, fig.width=6, fig.align='center'}
# Generate new heatmap
plotMetaclusterMFIs(fsom_dt, cols_to_cluster)

```

Examining this heatmap suggests that metacluster 3 and 11 may be subsets of gdT cells, but the somewhat low expression of TCRgd makes it difficult to determine this with much certainty. Sometimes, once the most obvious merging has been done, UMAPs and MFI heatmaps alone are no longer sufficient to make informed decisions. Two other notable functions are provided to give further info about the clusters, the first being `plotClusterMFIs()`. It functions almost identically to `plotMetaclusterMFIs()`, except that its rows are clusters, and it may be used to look at the clusters within a specific metacluster of interest via the parameter `metaclusters`. This is demonstrated below by calling the function on metaclusters 3 and 11.

```{r cluster-heatmap, fig.height=4, fig.width=7, fig.align='center'}
# Generate cluster MFI heatmap
plotClusterMFIs(fsom_dt, cols_to_cluster, metaclusters = c(3, 11))
```

It seems that clusters 4 and 42 have a particularly low expression of TCRgd, and express other markers that are barely present in the rest of this subset. This may be further investigated with the second notable function, `plotLabeled2DScatter()`. It creates a 2D scatterplot colored by metacluster, where each cluster center is labeled with its cluster's number. Below, this function is called on clusters 4 and 42, as well as cluster 76 to act as a point of reference.

```{r 2d-scatter, fig.height=5, fig.width=6, fig.align='center'}
# Generate 2D scatterplot
plotLabeled2DScatter(fsom_dt, 
                     channelpair = c("APC-Cy7-A", "BUV563-A"), 
                     clusters = c(4, 42, 76),
                     metaclusters = NULL)
```

Clusters 4 and 42 clearly do not have a high enough expression of TCRgd to justify classifying them as gdT cells. In fact, cluster 4 isn't defined by any significant phenotyping markers, and cluster 42 has high expression of multiple unrelated phenotyping markers, suggesting that it may be a population of cells that were stuck together. In the next merging step performed below, these clusters are reassigned to a new metacluster named `"Undefined"`. It is recommended to avoid reassigning clusters as much as possible, as doing so increases the subjectivity of the analysis, but it is ultimately up to the user to determine when this step is appropriate.

```{r second-merge}
# Merge metaclusters
fsom_dt <- editTableMetaclusters(fsom_dt, 
                                 new_labels = c("12" = "5",
                                                "13" = "5",
                                                "10" = "6",
                                                "14" = "6",
                                                "25" = "18",
                                                "16" = "11",
                                                "24" = "3"),
                                 cluster_assignments = c("4" = "Undefined",
                                                         "42" = "Undefined"))
```

```{r second-merge-alt, include=FALSE, eval=FALSE}
# Merge metaclusters
fsom <- FlowSOM::UpdateMetaclusters(fsom, 
                                    newLabels = c("12" = "5",
                                                  "13" = "5",
                                                  "10" = "6",
                                                  "14" = "6",
                                                  "25" = "18",
                                                  "16" = "11",
                                                  "24" = "3"),
                                    clusterAssignment = c("4" = "Undefined",
                                                          "42" = "Undefined"))
```

Again, new plots are generated.

```{r second-merge-plots, fig.height=5, fig.width=6, fig.align='center'}
# New heatmap
plotMetaclusterMFIs(fsom_dt, cols_to_cluster)

# New UMAP
plotUMAP(fsom_dt, num_cells = 5000, seed = 42)
```

Finally, once the clustering is complete, the remaining metaclusters may be labelled by setting each of them equal to the desired name, instead of another metacluster to be merged into.

```{r new-labels, fig.height=5, fig.width=6, fig.align='center'}
# Label metaclusters
fsom_dt <- editTableMetaclusters(fsom_dt, new_labels = c("6" = "Monocytes",
                                                         "5" = "cDC",
                                                         "4" = "B cells",
                                                         "17" = "NK T cells",
                                                         "19" = "NK cells",
                                                         "1" = "CD8 T cells",
                                                         "11" = "gdT cells",
                                                         "15" = "CD4 T cells",
                                                         "18" = "pDC",
                                                         "3" = "Undefined"))

# Generate final heatmap
plotMetaclusterMFIs(fsom_dt, cols_to_cluster)
```

```{r new-labels-alt, include=FALSE, eval=FALSE}
# Merge metaclusters
fsom <- FlowSOM::UpdateMetaclusters(fsom, 
                                    newLabels = c("6" = "Monocytes",
                                                  "5" = "cDC",
                                                  "4" = "B cells",
                                                  "17" = "NK T cells",
                                                  "19" = "NK cells",
                                                  "1" = "CD8 T cells",
                                                  "11" = "gdT cells",
                                                  "15" = "CD4 T cells",
                                                  "18" = "pDC",
                                                  "3" = "Undefined"))
```

An annotated heatmap displaying the merged clusters may be created with the function `annotateMFIHeatmap()`.

```{r annotate-heatmap, fig.height=5, fig.width=6, fig.align='center'}
# Generate annotated heatmap
annotateMFIHeatmap(fsom_dt, cols_to_cluster)
```

### Reclustering

This script also allows the user to perform backgating and reclustering on any identified cell types of particular interest. This clustering may be done using either a selected number of principal components obtained from PCA, or a new subset of markers defined by the user. The former approach is demonstrated below to further investigate the cells identified as CD8 T cells.

```{r subset}
# Get table of only CD8 T cells
new_table <- createFilteredAggregate(fsom_dt, 
                                     num_cells = Inf, 
                                     metaclusters = "CD8 T cells",
                                     clusters = NULL)
```

```{r subset-table, include=FALSE, eval=FALSE} 
new_table %>% 
  tidytable::select(tidytable::all_of(c("cell_id", "Meta_original", "Metacluster", "Cluster"))) %>%
  tidytable::slice_head(5) %>%
  data.frame() %>%
  knitr::kable(
    format = "html",
    align = "c",
    linesep = "",
    )
```

One an appropriate subset has been created, the next step is to create a scree plot, which may be used to determine which principal components should be used in the analysis. Typically, there is a distinct "elbow" in the plot, where the amount of variance explained by each component becomes drastically smaller. So, if this elbow appears at principal component 5, components 1-5 would be selected to recluster the data. If there is no obvious elbow, it is instead reasonable to use whichever number of components explains roughly 70-80% of the variance. First, `doPCA()` is called to perform PCA. Then, `plotPCAScree()` creates the scree plot.

```{r pca, fig.height=4, fig.width=6, fig.align='center'}
# Perform PCA
pca_obj <- doPCA(new_table, cols_to_cluster)

# Draw scree plot
plotPCAScree(pca_obj)
```

Here, there appears to be a fairly distinct elbow at `M = 6`. To recluster using these principal components, the following call to `clusterSubsetWithPCA()` is made, with `num_components = 6`. Fewer metaclusters are created than in the initial clustering, as fewer cell types are expected.

```{r reclustering}
# Recluster CD8 T cells
fsom_sub <- clusterSubsetWithPCA(new_table, 
                                 pca_obj = pca_obj, 
                                 num_components = 6,
                                 num_clus = 15,
                                 seed = 33)
```

Note that the plot functions demonstrated earlier function the same for any subsets created. Since the current cells of interest are CD8 T cells, it is appropriate to define a new subset of markers to create the heatmap.

```{r reclustering-plots, fig.height=6, fig.width=5, fig.align='center'}
# Define new columns to use
cols_of_interest <- c(15, 16, 18, 23:25, 28, 32)

# Generate heatmap for subsetted cells
plotMetaclusterMFIs(fsom_sub, cols_of_interest)

# Likewise, generate UMAP
plotUMAP(fsom_sub, num_cells = 5000, seed = 33)
```

## Plots

Various plotting functions that are not essential to the workflow, but potentially still of interest, have been included in this package. 

``` {r sample-proportions, fig.height=5, fig.width=6, fig.align='center'}
plotSampleProportions(fsom_dt)
```

- searchByExpression()
- plotLabeled2DScatter()
- plotClusterGroupProportions()
- plotClusterFileProportions()


# Differential Analysis

The final analysis step in this workflow is differential analysis. Differential marker expression is implemented using limma, and differential count analysis using edgeR, both R packages found on Bioconductor. 

Some preparation is necessary before any tests can be performed. First, it is necessary to specify information about each sample, including any FMO or isotype controls, and which groups of interest it belongs to (e.g. control vs. treatment). This information may be provided as a .csv file or `data.frame` to the function `prepareSampleInfo()`, which will prepare the table for further use by the workflow and ensure that its values are R-friendly (no special characters like @ or #, no empty values, etc.). Below is an example of what an appropriate .csv file might look like.

```{r sample-info, echo=FALSE} 
# Get filepath
file <- system.file("extdata", "sample_info.csv", package = "flowFun")
table <- read.csv(file)

table %>%
  knitr::kable(
    format = "html",
    align = "c",
    linesep = "",
    )
```

Before calling `prepareSampleInfo()`, the user must also specify the comparisons they wish to make between groups, as a series of nested lists. Each nested list should include at least two levels of a factor to be used for the comparison. Each comparison may be named however the user desires, given that it is R-friendly. Below, two comparisons, `ctrl_vs_mibc` and `nac_vs_no_nac` are defined.

```{r comparisons}
comparisons <- list(
  ctrl_vs_mibc = list(disease = list("MIBC", "Ctrl")),
  nac_vs_no_nac = list(disease = "MIBC", NAC = list("NAC", "No.NAC"))
)
```

The factor names (which would be "disease" and "NAC" in the above example), unlike the names of comparisons, should be identical to their column names in the .csv file or data frame given to `prepareSampleInfo()`. Similarly, the factor levels (which would be "Ctrl", "MIBC", "NAC", and "No NAC" in the above example), should be listed identical to how they appear in the data frame. Note how these values match those present in the table just shown.

Once these two items have been specified, the remainder of analysis is rather straightforward. `prepareSampleInfo()` is called, formatting the given table as necessary, and adding a new column called `group`.

```{r prep-sample-info}
# Get filepath
file <- system.file("extdata", "sample_info.csv", package = "flowFun")

# Prepare metadata for further analysis
sample_info <- prepareSampleInfo(file, 
                                 name_col = "sample.name",
                                 filename_col = "filename",
                                 comparisons = comparisons)
```

```{r print-sample-info, echo=FALSE}
sample_info %>%
  knitr::kable(
    format = "html",
    align = "c",
    linesep = "",
    )
```

Next, the design, contrasts, and count matrices are created. The current population of interest (in this case, `fsom_dt`) should be given to `makeCountMatrix()`. Furthermore, the parameter `meta_names` should be used to specify the metaclusters to use for analysis. By default, all metaclusters are included, but if the final merging included an undefined metacluster, or some are of no interest, it is useful to specify this parameter.

```{r matrices}
# Generate design matrix
design <- makeDesignMatrix(sample_info)

# Generate contrasts matrix
contrasts <- makeContrastsMatrix(sample_info, comparisons)

# Generate matrix of sample/metacluster cell counts
counts <- makeCountMatrix(fsom_dt, 
                          min_cells = 3, 
                          min_samples = 4)
```

The table of counts is printed below:

```{r print-counts, echo=FALSE}
colnames(counts) <- sample_info$filename
counts %>%
  knitr::kable(
    format = "html",
    align = "c",
    linesep = "",
    )
```

#### Differential Abundance

Once these matrices have been acquired, to perform differential abundance analysis, the user only needs to pass them to `doDAAnalysis()`, and specify a normalization method, if any. Results are returned as a list, where each entry is a table corresponding to a comparison. The tables are named after the comparison they correspond to, and contain results of likelihood ratio tests performed by edgeR, with each test being ranked by its adjusted p-value. 

Results are also saved as a .csv file for each comparison in the directory `Analysis Results/edgeR`. If running an edgeR analysis on multiple objects, or running the script multiple times for any reason, the user may wish to create sub-directories within `Analysis Results/edgeR` to stay organized. To do this, simply set the \code{dir_tables} parameter to a preferred sub-directory name.

```{r da-analysis}
# Perform differential abundance analysis
da_results <- doDAAnalysis(design = design, 
                           counts = counts, 
                           contrasts = contrasts,
                           sample_df = sample_info, 
                           norm_method = "TMM")
# for GS: flowWorkspace::gs_pop_get_counts()
```

The resulting individual tables may be accessed with either double brackets `[[]]` or `$`, e.g. `da_results[[1]]` or `da_results$MIBC_NAC__vs__MIBC_No.NAC`. In this example, two comparisons were tested, so the resulting list contains two tables:

```{r da-analysis-tables, echo=FALSE}
da_results[[1]] %>%
  knitr::kable(
    format = "html",
    align = "c",
    caption = "Ctrl vs. MIBC",
    linesep = "",
    )

da_results[[2]] %>%
  knitr::kable(
    format = "html",
    align = "c",
    caption = "NAC vs. No NAC",
    linesep = "",
    )
```

#### Differential Expression

To test for differential expression, the design, contrasts, and count matrices must again be specified, in addition to the markers to be tested. Recall that in most cases, these markers should not be the same as those used for clustering.

```{r de-analysis, include=FALSE, eval=FALSE}
# Perform differential expression analysis

# Find expression matrix: metacluster.marker by sample
collapsed <- getExprMatDE(fsom_dt, marker_cols)

# Create linear models.
# NOTE: weights questionable
lm_model <- limma::lmFit(object = collapsed,
                         design = design)

# Perform statistical tests.
contrasts_fit <- limma::contrasts.fit(lm_model, contrasts)
limma_ebayes <- limma::eBayes(contrasts_fit, trend = TRUE)

# View results
limma::topTable(limma_ebayes)
```

```{r de-analysis-tables, echo=FALSE, eval=FALSE,include=FALSE}
de_results[[1]] %>%
# de_results$tests[[1]] %>%
  knitr::kable(
    format = "html",
    align = "c",
    caption = "Ctrl vs. MIBC",
    linesep = "",
    )

de_results[[2]] %>%
# de_results$tests[[2]] %>%
  knitr::kable(
    format = "html",
    align = "c",
    caption = "NAC vs. No NAC",
    linesep = "",
    )
```



```{r extra, include=FALSE, eval=FALSE}
# fsom_dt$.id <- file.path(dirname(fsom_dt$.id), sample_info$filename[as.numeric(factor(fsom_dt$.id))])

fmos <- c("C:/Users/00ber/OneDrive/Desktop/VPC/human1/FMO/FMO_Ctrl AWB4.fcs", "C:/Users/00ber/OneDrive/Desktop/VPC/human1/FMO/FMO_Ctrl AWB9.fcs", "C:/Users/00ber/OneDrive/Desktop/VPC/human1/FMO/FMO_MIBC MR93.fcs", "C:/Users/00ber/OneDrive/Desktop/VPC/human1/FMO/FMO_MIBC MR66.fcs", "C:/Users/00ber/OneDrive/Desktop/VPC/human1/FMO/FMO_MIBC MR110.fcs", "C:/Users/00ber/OneDrive/Desktop/VPC/human1/FMO/FMO_MIBC MR75.fcs")

fs <- flowCore::read.flowSet(fmos, truncate_max_range = FALSE)
f1 <- flowCore::read.FCS(files[1], truncate_max_range = FALSE)

# gs <- flowWorkspace::GatingSet(fs, tmp = file.path(getwd(), "temp"))


ctrl_dt <- doPreprocessing(fmos,
                           ld_channel = attr(fsom_dt, "gating_scheme")$live_gate$channels[1],
                           compensation = attr(fsom_dt, "compensation_matrix"),
                           transformation = attr(fsom_dt, "transformation"),
                           transformation_type = "logicle",
                           debris_gate = attr(fsom_dt, "gating_scheme")$debris_gate,
                           live_gate = attr(fsom_dt, "gating_scheme")$live_gate,
                           save_plots = FALSE,
                           pctg_live = 0,
                           pctg_qc = 0)

# Turn filtered control files into flowSet
# ctrl_names <- ctrl_dt %>% pull(.id) %>% unique()
# ctrl_fs <- lapply(ctrl_names, function(i) {
#   ctrl_dt %>% 
#     filter(.id == i) %>% 
#     select(-c(1,2)) %>% 
#     as.matrix() %>% 
#     flowCore::flowFrame()})
# names(ctrl_fs) <- ctrl_names
# ctrl_fs <- methods::as(ctrl_fs, "flowSet")
ctrl_fs <- tableToFlowSet(ctrl_dt)

# Map new data to old FlowSOM codes
ctrl_fsom <- FlowSOM::NewData(fsom, ctrl_fs)

###
# steps for if data of interest is a reclustering? 
#
###

# helper to turn FlowSOM object into tidytable
# ??? edit flowSOMWrapper() to accept control table ???
ctrl_dt <- flowSOMToTable(ctrl_fsom)

# make table for second term in delta MFI
ctrl_mfis <- getSampleMetaclusterMFIsNew(ctrl_dt, sample_info, cols_to_use = c("PHA-L", "IL10R"))
# acquire this table for all controls, put into list, pass as ctrl_input
# make function to cluster/map control data to existing embedding

# ^ above could be contained within DE function for single channel? 

# differential expression
de_table <- doDEAnalysisNew(fsom_dt, 
                            sample_df = sample_info, 
                            design = design, 
                            contrasts = contrasts, 
                            cols_to_use = c("PHA-L", "IL10R"),
                            meta_names = meta_of_interest, 
                            ctrl_input = NULL, 
                            subsetted_meta = NULL, # remove need for this parameter
                            save_csv = FALSE, 
                            dir_tables = NULL)


#####
ctrl <- FlowSOM::ReadInput(fmos,
                           compensate = TRUE,
                           spillover = attr(fsom_dt, "compensation_matrix"),
                           transformList = attr(fsom_dt, "transformation"))

# ctrl_list <- list("PHA-L" = fmos)
ctrl_list <- list("PHA-L" = ctrl_dt)

fsom_dt <- editTableMetaclusters(fsom_dt, 
                                 new_labels = c("9" = "1",
                                                "2" = "1",
                                                "8" = "4",
                                                "23" = "15",
                                                "21" = "15",
                                                "20" = "15",
                                                "22" = "15",
                                                "7" = "6"))
fsom_dt <- editTableMetaclusters(fsom_dt, 
                                 new_labels = c("12" = "5",
                                                "13" = "5",
                                                "10" = "6",
                                                "14" = "6",
                                                "25" = "18",
                                                "16" = "11",
                                                "24" = "3"),
                                 cluster_assignments = c("4" = "Undefined", 
                                                         "42" = "Undefined"))

fsom_dt <- editTableMetaclusters(fsom_dt, new_labels = c("6" = "Monocytes",
                                                         "5" = "cDC",      
                                                         "4" = "B cells",     
                                                         "17" = "NK T cells",  
                                                         "19" = "NK cells",                                                                                                   "1" = "CD8 T cells",                                                                                                 "11" = "gdT cells",                                                                                                  "15" = "CD4 T cells",                                                                                                "18" = "pDC",                                                                                                        "3" = "Undefined"))
```
