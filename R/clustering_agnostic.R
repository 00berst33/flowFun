.datatable.aware <- TRUE

#' flowSOMWrapper
#'
#' @param table ...
#' @param cols_to_cluster ...
#' @param num_clus ...
#' @param seed ...
#' @param fsom_file ...
#' @param ... ...
#'
#' @return A data.table annotated with cluster and metacluster assignments.
#'
#' @export
flowSOMWrapper <- function(table, cols_to_cluster, num_clus, seed = NULL,
                           fsom_file = "flowsom_object.rds", ...) {
  if (is.numeric(cols_to_cluster)) {
    cols_to_cluster <- colnames(table)[cols_to_cluster] #edit?
  }

  # Set input data.table to appropriate format
  prepr_mat <- as.matrix(table, rownames = TRUE)

  # Run clustering algorithm
  fsom <- FlowSOM::FlowSOM(prepr_mat,
                           colsToUse = cols_to_cluster,
                           nClus = num_clus,
                           seed = seed)

  # Get metacluster and cluster labels
  meta_labels <- FlowSOM::GetMetaclusters(fsom)
  clust_labels <- factor(FlowSOM::GetClusters(fsom))

  # Append labels as columns to the data.table
  table <- table %>%
    tidytable::mutate(Cluster = clust_labels,
                      Meta_original = meta_labels,
                      .keep = "all")

  attr(table, "clustered") <- cols_to_cluster

  # Save FlowSOM object as .rds file if desired.
  if (!is.null(fsom_file)) {
    saveRDS(fsom, file.path("RDS", "Unedited", fsom_file))
  }

  return(table)
}

#' editTableMetaclusters
#'
#' Merge or relabel metaclusters, and reassign clusters.
#'
#' @param table A data table that has been clustered by [flowSOMWrapper()].
#' @param new_labels Optional. A named vector, where names are the original metacluster names,
#' and values are the new labels.
#' @param cluster_assignments Optional. A named vector, where names are the cluster numbers,
#' and values are metacluster names.
#' @param level_order A character vector giving the desired order of the metacluster labels.
#'
#' @return A data.table with an added column \code{Meta_edited}.
#'
#' @export
editTableMetaclusters <- function(table, new_labels = NULL, cluster_assignments = NULL, level_order = NULL) {
  # Check if a merging has already been done, to determine whether to edit or create column
  if ("Meta_edited" %in% colnames(table)) {
    col <- "Meta_edited"
  } else {
    col <- "Meta_original"
  }

  # If new metaclusters labels are given
  if (!is.null(new_labels) & !is.null(names(new_labels))) {
    temp <- levels(table[[col]])
    new <- temp # values are new labels
    names(new) <- temp # names are original labels

    # Assign new labels for each given metacluster
    for (original_label in names(new_labels)) {
      new[temp == original_label] <- new_labels[original_label]
    }

    # If any metaclusters were merged, or if this is the first time this function has been called on this table
    if (any(duplicated(new)) | col == "Meta_original") {
      # Create or edit column `Meta_edited` to contain new labels
      table <- table %>%
        tidytable::mutate(Meta_edited = new[as.character(table[[col]])])
      table$Meta_edited <- factor(table$Meta_edited, levels = unique(new))
    } else { # If metaclusters were only renamed, no merging
      levels(table$Meta_edited) <- new
    }
  }
  # If new metacluster assignments for a set of clusters is given
  if (!is.null(cluster_assignments) & !is.null(names(cluster_assignments))) {
    temp <- table[[col]]
    new <- as.character(temp) # values are metacluster assignments
    names(new) <- as.character(table$Cluster) # names are cluster assignments

    # Assign new metacluster for each given cluster
    for (original_assignment in names(cluster_assignments)) {
      new[which(names(new) == original_assignment)] <- cluster_assignments[original_assignment]
    }
    # Create or edit column `Meta_edited` to contain new labels
    table <- table %>%
      tidytable::mutate(Meta_edited = factor(x = new))
  }
  # If a level order for new metacluster labels is given
  if(!is.null(level_order) & "Meta_edited" %in% colnames(table)) {
    table$Meta_edited <- factor(table$Meta_edited, levels = level_order)
  }

  return(table)
}

#' filterData
#'
#' @param data ...
#' @param clusters A character vector specifying which clusters to keep. Default
#' is \code{NULL}.
#' @param metaclusters A character vector specifying which metaclusters to keep.
#' Default is \code{NULL}.
#'
#' @return A data.table, where only cells belonging to the given clusters or
#' metaclusters are included.
#'
#' @export
filterData <- function(data, clusters = NULL, metaclusters = NULL) {
  Meta_original <- Cluster <- NULL

  if (is.null(clusters)) {
    clusters <- levels(data$Cluster)
  }
  if (is.null(metaclusters)) {
    metaclusters <- levels(data$Meta_original)
  }

  filtered <- data %>%
    tidytable::filter(Meta_original %in% metaclusters & Cluster %in% clusters)

  return(filtered)
}

#' createFilteredAggregate
#'
#' Filter preprocessed .fcs files to create a new aggregate file.
#'
#' @param data A FlowSOM object as generated by \code{\link[FlowSOM:FlowSOM]{FlowSOM()}}.
#' @param num_cells The total number of cells to include in the aggregate file.
#' @param clusters A numeric vector listing the clusters of interest.
#' @param metaclusters A character vector listing the metaclusters of interest.
#' @param agg_name An .fcs filename. Default is "filtered_aggregate.fcs".
#' @param dir_save If a directory path is given, then the filtered .fcs
#' files used to create the aggregate file will be saved there. If \code{NULL}
#' (default), then they will be discarded.
#'
#' @details
#' It is only necessary to define one of the arguments \code{clusters} and
#' \code{metaclusters}, but the user may use both if they wish.
#'
#' This function takes in a group of clustered .fcs files, as generated
#' by [FlowSOM::SaveClustersToFCS()], and subsets them to create a new set of
#' .fcs files that contain only the cells included in the given metaclusters
#' and/or clusters. If desired, these new .fcs files are then written to a new
#' directory, whose name is specified by the user with the \code{dir_save}
#' parameter. Note that it is only necessary to save the files if you intend to perform
#' additional reclustering on them, otherwise they may be safely deleted. The
#' aggregate file is written to the directory saved in \code{dir_agg()} under the
#' name specified by \code{agg_name}.
#'
#' @return An aggregated \code{\link[flowCore]{flowFrame}}, where only cells
#' belonging to the given metaclusters and/or clusters are included.
#'
#' @export
createFilteredAggregateTable <- function(data, num_cells, clusters = NULL,
                                         metaclusters = NULL,
                                         agg_name = "filtered_aggregate.fcs",
                                         dir_save = NULL) {
  .id <- cell_id <- NULL

  # Filter cells not of interest out of data
  cells_of_interest <- filterData(data, clusters = clusters, metaclusters = metaclusters)

  # Get all sample file names
  files <- data %>%
    tidytable::pull(.id) %>%
    unique()

  # Get number of cells to sample per file
  per_sample <- ceiling(num_cells/length(files))

  # Sample equal number of cells from each sample
  all_inds <- c()
  for (file in files) {
    # Get all cells belonging to current sample
    sample_cells <- cells_of_interest %>%
      tidytable::filter(.id == file) %>%
      tidytable::pull(cell_id)

    # Sample cells and subset table
    inds <- sample(sample_cells, per_sample)
    all_inds <- c(all_inds, inds)
  }

  # Select sampled rows from data table
  agg <- cells_of_interest %>%
    tidytable::filter(cell_id %in% all_inds)

  # write clusters to original .fcs files? `agg_name` not used

  return(agg)
}


# saveClustersFCS <- function(data, fsom, dir_save) {
#   files <- data %>%
#     tidytable::pull(.id) %>%
#     unique()
#
#   FlowSOM::SaveClustersToFCS(fsom,
#                              originalFiles = files,
#                              outputDir = dir_save)
#
#   full_table <- getTableFromFCS(dir_save) # metacluster and cluster labels?
#
#   return(full_table)
# }

#' doPCA
#'
#' @param input A data frame.
#' @param cols_to_use Columns of the input to use for PCA.
#'
#' @return A prcomp object.
#'
#' @export
doPCA <- function(input, cols_to_use) {
  expr_data <- input %>%
    tidytable::select(cols_to_use)

  pca <- stats::prcomp(expr_data)
  return(pca)
}

#' clusterTableWithPCA
#'
#' Recluster a subset of flow data using principal components of an aggregate
#' date table.
#'
#' @param aggregate An aggregate data table, as generated by [createFilteredAggregateTable()].
#' @param pca_obj A \code{\link[stats]{prcomp}} object as generated by [doAggregatePCA()]
#' @param num_components The number of principal components to use for reclustering,
#' as determined by examining results of [plotPCAScree()].
#' @param num_clus The number of metaclusters you would like.
#' @param xdim x-dimension of the SOM. Default is 10.
#' @param ydim y-dimension of the SOM. Default is 10.
#' @param seed A seed for reproducible results. Default is \code{NULL}.
#' @param convert_to_channels Logical, should the returned FlowSOM object's data
#' be defined in terms of channels. Default is \code{TRUE}.
#'
#' @details
#' When reclustering a subset of flow data, such as a cell population that has
#' been identified as monocytes, not every marker you used for the initial clustering
#' is still relevant. In such a case, you would no longer be interested in using,
#' for instance, a B cell marker. One solution is to leave it up to the
#' researcher to determine what markers are appropriate for the reclustering,
#' but this approach is very user-dependent, therefore lacking reproducibility.
#'
#' This function solves this problem by using PCA for reclustering. It
#' takes in an aggregate .fcs file, as generated by \code{createFilteredAggregate()},
#' and clusters the cells within it using the specified number of principal
#' components. If \code{convert_to_channels} is \code{TRUE} (default), it then
#' takes the cluster and metacluster assignments found from this clustering to
#' create a FlowSOM object defined in terms of channels, rather than
#' principal components, so that it may still be used with both the functions
#' in flowFun and in FlowSOM.
#'
#' @return A FlowSOM object.
#'
#' @export
clusterTableWithPCA <- function(aggregate, pca_obj, num_components,
                                num_clus, xdim = 10, ydim = 10, seed = NULL,
                                convert_to_channels = TRUE) {
  .id <- cell_id <- NULL

  # Select specified principal components
  selected_pca_cols <- pca_obj$x[, 1:num_components]

  # Add file and ID columns to input
  id_cols <- aggregate %>%
    tidytable::select(.id, cell_id) %>%
    data.frame(check.names = FALSE)

  fsom_input <- cbind(selected_pca_cols,
                      id_cols)

  # New FlowSOM object
  fsom_subset <- FlowSOM::FlowSOM(fsom_input,
                                  colsToUse = colnames(fsom_input[, 1:num_components]),
                                  nClus = num_clus,
                                  xdim = xdim,
                                  ydim = ydim,
                                  seed = seed)

  if (convert_to_channels) {
    fsom_subset <- revertPCAFlowSOM(fsom_subset, aggregate, pca_obj, num_components)
  }

  saveRDS(fsom_subset, paste0(dir_rds_unedited(), "new_fsom.rds")) # make optional

  return(fsom_subset) # return data table instead
}

###
#' Title
#'
#' *parameter tweaking
#'
#' @param input ...
#' @param num_cells ...
#' @param seed ...
#'
#' @return ...
#'
#' @export
plotUMAPNew <- function(input, num_cells = 5000, seed = NULL) {
  X1 <- X2 <- Metacluster <- NULL

  if (!is.null(seed)) {
    set.seed(seed)
  }

  if (methods::is(input, "FlowSOM")) {
    cols_used <- input$map$colsUsed
    meta_vec <- FlowSOM::GetMetaclusters(input)

    input <- input$data[, cols_used]
  } else if (methods::is(input, "data.table")) {
    cols_used <- attributes(input)$clustered

    if ("Meta_edited" %in% colnames(input)) {
      meta_vec <- input$Meta_edited
    } else {
      meta_vec <- input$Meta_original
    }

    input <- input %>%
      tidytable::select(cols_used)
  }

  nrows <- nrow(input)

  if (num_cells < nrows) {
    inds <- sample(nrows, num_cells)
  } else {
    inds <- 1:nrows
  }

  data <- input[inds, ]
  umap <- umap::umap(data)
  meta_vec <- meta_vec[inds]

  # add parameter for choosing order of legend

  umap_df <- data.frame(umap$layout, Metacluster = meta_vec, Indices = inds)

  # Draw plot
  p <- ggplot2::ggplot(umap_df) +
    scattermore::geom_scattermore(ggplot2::aes(x = X1, y = X2,
                                               color = Metacluster),
                                  pointsize = 2) +
    ggplot2::theme_void() +
    ggplot2::theme(aspect.ratio = 1)
  print(p)

  return(p)
}

###
#' Title
#'
#' @param input
#' @param cols_to_use
#' @param ...
#'
#' @return
#' @export
plotMetaclusterMFIsNew = function(input, cols_to_use = NULL, ...) {
  # if (methods::is(input, "FlowSOM")) {
  #   cols_to_use <- input$map$colsUsed
  # } else
  if (methods::is(input, "data.table") & is.null(cols_to_use)) {
    cols_to_use <- attributes(input)$clustered
  }

  # Get metacluster MFIs for each marker/channel of interest
  mfi_mat <- input %>%
    tidytable::summarise(tidytable::across(.cols = cols_to_use, # column
                                           .fns = stats::median,
                                           .drop = "keep"),
                         .by = Meta_original)
  mfi_mat <- as.matrix(mfi_mat, rownames = "Meta_original")

  # Set default heatmap options
  default_options <- list(border = TRUE,
                          show_row_names = TRUE,
                          heatmap_legend_param = list(
                            title = "Expression",
                            title_gp = grid::gpar(fontsize = 9),
                            labels_gp = grid::gpar(fontsize = 8)))

  # Add any additional options chosen by user, and overwrite defaults if needed
  additional_options <- list(...)
  heatmap_options <- utils::modifyList(default_options, additional_options)

  # Generate heatmap
  mfi_heatmap <- do.call(ComplexHeatmap::Heatmap, c(list(matrix = mfi_mat), heatmap_options))

  return(mfi_heatmap)
}
