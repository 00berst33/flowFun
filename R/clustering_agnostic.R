.datatable.aware <- TRUE

#' flowSOMWrapper
#'
#' @param table ...
#' @param markers_to_cluster ...
#' @param num_clus ...
#' @param seed ...
#' @param fsom_file ...
#' @param ... ...
#'
#' @return A data.table annotated with cluster and metacluster assignments.
#'
#' @export
flowSOMWrapper <- function(table, markers_to_cluster, num_clus, seed = NULL,
                           fsom_file = "flowsom_object.rds", ...) {
  if (is.numeric(markers_to_cluster)) {
    markers_to_cluster <- colnames(table)[markers_to_cluster] #edit?
  }

  # Set input data.table to appropriate format
  prepr_mat <- as.matrix(table, rownames = TRUE)

  # Run clustering algorithm
  fsom <- FlowSOM::FlowSOM(prepr_mat,
                           colsToUse = markers_to_cluster,
                           nClus = num_clus,
                           seed = seed)

  # Get metacluster and cluster labels
  meta_labels <- FlowSOM::GetMetaclusters(fsom)
  clust_labels <- factor(FlowSOM::GetClusters(fsom))

  # Append labels as columns to the data.table
  table <- table %>%
    tidytable::mutate(Cluster = clust_labels,
                      Meta_original = meta_labels,
                      .keep = "all")

  # Save FlowSOM object as .rds file if desired.
  if (!is.null(fsom_file)) {
    saveRDS(fsom, file.path("RDS", "Unedited", fsom_file))
  }

  return(table)
}

#' editTableMetaclusters
#' 
#' Merge or relabel metaclusters, and reassign clusters.
#'
#' @param table A data table that has been clustered by [flowSOMWrapper()].
#' @param new_labels Optional. A named vector, where names are the original metacluster names,
#' and values are the new labels.
#' @param cluster_assignments Optional. A named vector, where names are the cluster numbers,
#' and values are metacluster names.
#' @param level_order A character vector giving the desired order of the metacluster labels.
#'
#' @return A data.table with an added column \code{Meta_edited}.
#' 
#' @export
editTableMetaclusters <- function(table, new_labels = NULL, cluster_assignments = NULL, level_order = NULL) {
  # Check if a merging has already been done, to determine whether to edit or create column
  if ("Meta_edited" %in% colnames(table)) {
    col <- "Meta_edited"
  } else {
    col <- "Meta_original"
  }
  
  # If new metaclusters labels are given
  if (!is.null(new_labels) & !is.null(names(new_labels))) {
    temp <- levels(table[[col]])
    new <- temp # values are new labels
    names(new) <- temp # names are original labels
    
    # Assign new labels for each given metacluster
    for (original_label in names(new_labels)) { 
      new[temp == original_label] <- new_labels[original_label]
    }
    
    # If any metaclusters were merged, or if this is the first time this function has been called on this table
    if (any(duplicated(new)) | col == "Meta_original") {
      # Create or edit column `Meta_edited` to contain new labels
      table <- table %>%
        tidytable::mutate(Meta_edited = new[as.character(table[[col]])])
      table$Meta_edited <- factor(table$Meta_edited, levels = unique(new))
    } else { # If metaclusters were only renamed, no merging
      levels(table$Meta_edited) <- new
    }
  }
  # If new metacluster assignments for a set of clusters is given
  if (!is.null(cluster_assignments) & !is.null(names(cluster_assignments))) {
    temp <- table[[col]]
    new <- as.character(temp) # values are metacluster assignments
    names(new) <- as.character(table$Cluster) # names are cluster assignments
  
    # Assign new metacluster for each given cluster
    for (original_assignment in names(cluster_assignments)) {
      new[which(names(new) == original_assignment)] <- cluster_assignments[original_assignment]
    }
    # Create or edit column `Meta_edited` to contain new labels
    table <- table %>%
      tidytable::mutate(Meta_edited = factor(x = new))
  }
  # If a level order for new metacluster labels is given
  if(!is.null(level_order) & "Meta_edited" %in% colnames(table)) {
    table$Meta_edited <- factor(table$Meta_edited, levels = level_order)
  }
  
  return(table)
}

#' filterData
#'
#' @param data ...
#' @param clusters A character vector specifying which clusters to keep. Default
#' is \code{NULL}.
#' @param metaclusters A character vector specifying which metaclusters to keep.
#' Default is \code{NULL}.
#'
#' @return A data.table, where only cells belonging to the given clusters or
#' metaclusters are included.
#'
#' @export
filterData <- function(data, clusters = NULL, metaclusters = NULL) {
  Meta_original <- Cluster <- NULL

  if (is.null(clusters)) {
    clusters <- levels(data$Cluster)
  }
  if (is.null(metaclusters)) {
    metaclusters <- levels(data$Meta_original)
  }

  filtered <- data %>%
    tidytable::filter(Meta_original %in% metaclusters & Cluster %in% clusters)

  return(filtered)
}

#' createFilteredAggregate
#'
#' Filter preprocessed .fcs files to create a new aggregate file.
#'
#' @param data A FlowSOM object as generated by \code{\link[FlowSOM:FlowSOM]{FlowSOM()}}.
#' @param num_cells The total number of cells to include in the aggregate file.
#' @param clusters A numeric vector listing the clusters of interest.
#' @param metaclusters A character vector listing the metaclusters of interest.
#' @param agg_name An .fcs filename. Default is "filtered_aggregate.fcs".
#' @param dir_save If a directory path is given, then the filtered .fcs
#' files used to create the aggregate file will be saved there. If \code{NULL}
#' (default), then they will be discarded.
#'
#' @details
#' It is only necessary to define one of the arguments \code{clusters} and
#' \code{metaclusters}, but the user may use both if they wish.
#'
#' This function takes in a group of clustered .fcs files, as generated
#' by [FlowSOM::SaveClustersToFCS()], and subsets them to create a new set of
#' .fcs files that contain only the cells included in the given metaclusters
#' and/or clusters. If desired, these new .fcs files are then written to a new
#' directory, whose name is specified by the user with the \code{dir_save}
#' parameter. Note that it is only necessary to save the files if you intend to perform
#' additional reclustering on them, otherwise they may be safely deleted. The
#' aggregate file is written to the directory saved in \code{dir_agg()} under the
#' name specified by \code{agg_name}.
#'
#' @return An aggregated \code{\link[flowCore]{flowFrame}}, where only cells
#' belonging to the given metaclusters and/or clusters are included.
#'
#' @export
createFilteredAggregateTable <- function(data, num_cells, clusters = NULL,
                                         metaclusters = NULL,
                                         agg_name = "filtered_aggregate.fcs",
                                         dir_save = NULL) {
  .id <- cell_id <- NULL

  # Filter cells not of interest out of data
  cells_of_interest <- filterData(data, clusters = clusters, metaclusters = metaclusters)

  # Get all sample file names
  files <- data %>%
    tidytable::pull(.id) %>%
    unique()

  # Get number of cells to sample per file
  per_sample <- ceiling(num_cells/length(files))

  # Sample equal number of cells from each sample
  all_inds <- c()
  for (file in files) {
    # Get all cells belonging to current sample
    sample_cells <- cells_of_interest %>%
      tidytable::filter(.id == file) %>%
      tidytable::pull(cell_id)

    # Sample cells and subset table
    inds <- sample(sample_cells, per_sample)
    all_inds <- c(all_inds, inds)
  }

  # Select sampled rows from data table
  agg <- cells_of_interest %>%
    tidytable::filter(cell_id %in% all_inds)

  # write clusters to original .fcs files? `agg_name` not used

  return(agg)
}


# saveClustersFCS <- function(data, fsom, dir_save) {
#   files <- data %>%
#     tidytable::pull(.id) %>%
#     unique()
#
#   FlowSOM::SaveClustersToFCS(fsom,
#                              originalFiles = files,
#                              outputDir = dir_save)
#
#   full_table <- getTableFromFCS(dir_save) # metacluster and cluster labels?
#
#   return(full_table)
# }

# doAggregatePCA <- function(data, markers_to_cluster) {
#   expr_data <- data %>%
#     tidytable::select(markers_to_cluster)
#
#   pca <- stats::prcomp(expr_data)
#   return(pca)
# }

#' clusterTableWithPCA
#'
#' Recluster a subset of flow data using principal components of an aggregate
#' date table.
#'
#' @param aggregate An aggregate data table, as generated by [createFilteredAggregateTable()].
#' @param pca_obj A \code{\link[stats]{prcomp}} object as generated by [doAggregatePCA()]
#' @param num_components The number of principal components to use for reclustering,
#' as determined by examining results of [plotPCAScree()].
#' @param num_clus The number of metaclusters you would like.
#' @param xdim x-dimension of the SOM. Default is 10.
#' @param ydim y-dimension of the SOM. Default is 10.
#' @param seed A seed for reproducible results. Default is \code{NULL}.
#' @param convert_to_channels Logical, should the returned FlowSOM object's data
#' be defined in terms of channels. Default is \code{TRUE}.
#'
#' @details
#' When reclustering a subset of flow data, such as a cell population that has
#' been identified as monocytes, not every marker you used for the initial clustering
#' is still relevant. In such a case, you would no longer be interested in using,
#' for instance, a B cell marker. One solution is to leave it up to the
#' researcher to determine what markers are appropriate for the reclustering,
#' but this approach is very user-dependent, therefore lacking reproducibility.
#'
#' This function solves this problem by using PCA for reclustering. It
#' takes in an aggregate .fcs file, as generated by \code{createFilteredAggregate()},
#' and clusters the cells within it using the specified number of principal
#' components. If \code{convert_to_channels} is \code{TRUE} (default), it then
#' takes the cluster and metacluster assignments found from this clustering to
#' create a FlowSOM object defined in terms of channels, rather than
#' principal components, so that it may still be used with both the functions
#' in flowFun and in FlowSOM.
#'
#' @return A FlowSOM object.
#'
#' @export
clusterTableWithPCA <- function(aggregate, pca_obj, num_components,
                                num_clus, xdim = 10, ydim = 10, seed = NULL,
                                convert_to_channels = TRUE) {
  .id <- cell_id <- NULL

  # Select specified principal components
  selected_pca_cols <- pca_obj$x[, 1:num_components]

  # Add file and ID columns to input
  id_cols <- aggregate %>%
    tidytable::select(.id, cell_id) %>%
    data.frame(check.names = FALSE)

  fsom_input <- cbind(selected_pca_cols,
                      id_cols)

  # New FlowSOM object
  fsom_subset <- FlowSOM::FlowSOM(fsom_input,
                                  colsToUse = colnames(fsom_input[, 1:num_components]),
                                  nClus = num_clus,
                                  xdim = xdim,
                                  ydim = ydim,
                                  seed = seed)

  if (convert_to_channels) {
    fsom_subset <- revertPCAFlowSOM(fsom_subset, aggregate, pca_obj, num_components)
  }

  saveRDS(fsom_subset, paste0(dir_rds_unedited(), "new_fsom.rds")) # make optional

  return(fsom_subset) # return data table instead
}
