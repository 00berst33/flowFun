.datatable.aware <- TRUE

#' flowSOMWrapper
#'
#' @param table ...
#' @param markers_to_cluster ...
#' @param num_clus ...
#' @param seed ...
#' @param fsom_file ...
#' @param ... ...
#'
#' @return A data.table annotated with cluster and metacluster assignments.
#' 
#' @export
flowSOMWrapper <- function(table, markers_to_cluster, num_clus, seed = NULL, 
                           fsom_file = "flowsom_object.rds", ...) {
  if (is.numeric(markers_to_cluster)) {
    markers_to_cluster <- colnames(table)[markers_to_cluster] #edit?
  }
  
  # Set input data.table to appropriate format
  prepr_mat <- as.matrix(table, rownames = TRUE)
  
  # Run clustering algorithm
  fsom <- FlowSOM::FlowSOM(prepr_mat,
                           colsToUse = markers_to_cluster,
                           nClus = num_clus,
                           seed = seed)
  
  # Get metacluster and cluster labels
  meta_labels <- FlowSOM::GetMetaclusters(fsom)
  clust_labels <- factor(FlowSOM::GetClusters(fsom))
  
  # Append labels as columns to the data.table
  table <- table %>%
    tidytable::mutate(Cluster = clust_labels,
                      Meta_original = meta_labels,
                      .keep = "all")
  
  # Save FlowSOM object as .rds file if desired.
  if (!is.null(fsom_file)) {
    saveRDS(fsom, file.path("RDS", "Unedited", fsom_file))
  }
  
  return(table)
}

#' filterData
#'
#' @param data ...
#' @param clusters A character vector specifying which clusters to keep. Default
#' is \code{NULL}.
#' @param metaclusters A character vector specifying which metaclusters to keep.
#' Default is \code{NULL}.
#'
#' @return A data.table, where only cells belonging to the given clusters or
#' metaclusters are included.
#'
#' @export
filterData <- function(data, clusters = NULL, metaclusters = NULL) {
  Meta_original <- Cluster <- NULL
  
  if (is.null(clusters)) {
    clusters <- levels(data$Cluster)
  }
  if (is.null(metaclusters)) {
    metaclusters <- levels(data$Meta_original)
  }
  
  filtered <- data %>%
    tidytable::filter(Meta_original %in% metaclusters & Cluster %in% clusters)
  
  return(filtered)
}

#' createFilteredAggregate
#'
#' Filter preprocessed .fcs files to create a new aggregate file.
#'
#' @param data A FlowSOM object as generated by \code{\link[FlowSOM:FlowSOM]{FlowSOM()}}.
#' @param num_cells The total number of cells to include in the aggregate file.
#' @param clusters A numeric vector listing the clusters of interest.
#' @param metaclusters A character vector listing the metaclusters of interest.
#' @param agg_name An .fcs filename. Default is "filtered_aggregate.fcs".
#' @param dir_save If a directory path is given, then the filtered .fcs
#' files used to create the aggregate file will be saved there. If \code{NULL}
#' (default), then they will be discarded.
#'
#' @details
#' It is only necessary to define one of the arguments \code{clusters} and
#' \code{metaclusters}, but the user may use both if they wish.
#'
#' This function takes in a group of clustered .fcs files, as generated
#' by [FlowSOM::SaveClustersToFCS()], and subsets them to create a new set of
#' .fcs files that contain only the cells included in the given metaclusters
#' and/or clusters. If desired, these new .fcs files are then written to a new
#' directory, whose name is specified by the user with the \code{dir_save}
#' parameter. Note that it is only necessary to save the files if you intend to perform
#' additional reclustering on them, otherwise they may be safely deleted. The
#' aggregate file is written to the directory saved in \code{dir_agg()} under the
#' name specified by \code{agg_name}.
#'
#' @return An aggregated \code{\link[flowCore]{flowFrame}}, where only cells
#' belonging to the given metaclusters and/or clusters are included.
#'
#' @export
createFilteredAggregateTable <- function(data, num_cells, clusters = NULL,
                                         metaclusters = NULL,
                                         agg_name = "filtered_aggregate.fcs",
                                         dir_save = NULL) {
  .id <- cell_id <- NULL
  
  # Filter cells not of interest out of data
  cells_of_interest <- filterData(data, clusters = clusters, metaclusters = metaclusters)
  
  # Get all sample file names
  files <- data %>%
    tidytable::pull(.id) %>%
    unique()
  
  # Get number of cells to sample per file
  per_sample <- ceiling(num_cells/length(files))
  
  # Sample equal number of cells from each sample
  all_inds <- c()
  for (file in files) {
    # Get all cells belonging to current sample
    sample_cells <- cells_of_interest %>%
      tidytable::filter(.id == file) %>%
      tidytable::pull(cell_id)
    
    # Sample cells and subset table
    inds <- sample(sample_cells, per_sample)
    all_inds <- c(all_inds, inds)
  }
  
  # Select sampled rows from data table
  agg <- cells_of_interest %>%
    tidytable::filter(cell_id %in% all_inds)
  
  # write clusters to original .fcs files? `agg_name` not used

  return(agg)
}


# saveClustersFCS <- function(data, fsom, dir_save) {
#   files <- data %>%
#     tidytable::pull(.id) %>%
#     unique()
#   
#   FlowSOM::SaveClustersToFCS(fsom, 
#                              originalFiles = files, 
#                              outputDir = dir_save)
#   
#   full_table <- getTableFromFCS(dir_save) # metacluster and cluster labels?
#   
#   return(full_table)
# }

# doAggregatePCA <- function(data, markers_to_cluster) {
#   expr_data <- data %>%
#     tidytable::select(markers_to_cluster)
#   
#   pca <- stats::prcomp(expr_data)
#   return(pca)
# }

