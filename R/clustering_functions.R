#' filterFCS
#'
#' @param ff A \code{\link[flowCore]{flowFrame}}.
#' @param clusters A character vector specifying which clusters to keep. Default
#' is \code{NULL}.
#' @param metaclusters A character vector specifying which metaclusters to keep.
#' Default is \code{NULL}.
#'
#' @return A flowFrame, where only cells belonging to the given clusters or
#' metaclusters are included.
#'
#' @export
filterFCS <- function(ff, clusters = NULL, metaclusters = NULL) {
  filter_clust <- flowCore::exprs(ff)[,"FlowSOM_cluster"] %in% clusters
  filter_meta <- flowCore::exprs(ff)[,"FlowSOM_meta"] %in% metaclusters
  filter <- which(filter_clust | filter_meta)

  filtered <- ff[filter]
  return(filtered)
}

#' createFilteredAggregate
#'
#' Filter preprocessed data to create a new aggregate file.
#'
#' @param input A FlowSOM object as generated by \code{\link[FlowSOM:FlowSOM]{FlowSOM()}}, or
#' a \code{data.table}.
#' @param num_cells The total number of cells to include in the aggregate file.
#' @param clusters A numeric vector listing the clusters of interest.
#' @param metaclusters A character vector listing the metaclusters of interest.
#' @param agg_name An .fcs filename. Default is "filtered_aggregate.fcs".
#' @param dir_save If a directory path is given, then the filtered .fcs
#' files used to create the aggregate file will be saved there. If \code{NULL}
#' (default), then they will be discarded.
#'
#' @details
#' It is only necessary to define one of the arguments \code{clusters} and
#' \code{metaclusters}, but the user may use both if they wish.
#'
#' This function takes in a group of clustered .fcs files, as generated
#' by [FlowSOM::SaveClustersToFCS()], and subsets them to create a new set of
#' .fcs files that contain only the cells included in the given metaclusters
#' and/or clusters. If desired, these new .fcs files are then written to a new
#' directory, whose name is specified by the user with the \code{dir_save}
#' parameter. Note that it is only necessary to save the files if you intend to perform
#' additional reclustering on them, otherwise they may be safely deleted. The
#' aggregate file is written to the directory saved in \code{dir_agg()} under the
#' name specified by \code{agg_name}.
#'
#' @return An aggregated \code{\link[flowCore]{flowFrame}}, where only cells
#' belonging to the given metaclusters and/or clusters are included.
#'
#' @export
createFilteredAggregate <- function(input, num_cells, clusters = NULL,
                                    metaclusters = NULL,
                                    agg_name = "filtered_aggregate.fcs",
                                    dir_save = NULL) {
  result <- UseMethod("createFilteredAggregate")
  return(result)
}

#' createFilteredAggregate.FlowSOM
#'
#' Filter FlowSOM object to create a new aggregate file.
#'
#' @keywords internal
#' @export
createFilteredAggregate.FlowSOM <- function(input, num_cells, clusters = NULL,
                                            metaclusters = NULL,
                                            agg_name = "filtered_aggregate.fcs",
                                            dir_save = NULL) {
  if (!inherits(input, "FlowSOM")) {
    stop("The object is not a FlowSOM object")
  }

  print(paste0("Creating aggregate with files from directory ", dir_clustr(), "..."))

  # Filter cells not of interest out of data
  metaclusters <- which(levels(input$metaclustering) == metaclusters)
  frames <- lapply(list.files(dir_clustr(), full.names = TRUE), flowCore::read.FCS)
  filtered_frames <- lapply(frames, filterFCS, clusters, metaclusters)

  # Save the filtered .fcs files, if desired
  if (!is.null(dir_save) && !dir.exists(dir_save)) {
    dir.create(dir_save)

    names(filtered_frames) <- paste0(dir_save, list.files(dir_prepr()))

    for (i in 1:length(filtered_frames)) {
      flowCore::write.FCS(x = methods::as(filtered_frames[[i]], "flowFrame"),
                          filename = names(filtered_frames)[i])
    }
  }

  # Create and save new aggregated .fcs file
  filtered_fs <- methods::as(filtered_frames, "flowSet")
  agg <- FlowSOM::AggregateFlowFrames(filtered_fs,
                                      cTotal = num_cells,
                                      writeOutput = TRUE,
                                      outputFile = agg_name)
                                      # outputFile = paste0(dir_agg(), agg_name))
  return(agg)
}

#' createFilteredAggregate.data.frame
#'
#' Filter data frame to create a new aggregate file.
#'
#' @keywords internal
#' @export
createFilteredAggregate.data.frame <- function(input, num_cells, clusters = NULL,
                                               metaclusters = NULL,
                                               agg_name = "filtered_aggregate.fcs",
                                               dir_save = NULL) {
  if (!inherits(input, "data.frame")) {
    stop("The object is not a data frame")
  }

  .id <- cell_id <- NULL

  # Filter cells not of interest out of input
  cells_of_interest <- filterData(input, clusters = clusters, metaclusters = metaclusters)

  # Get all sample file names
  files <- input %>%
    tidytable::pull(.id) %>%
    unique()

  # Get number of cells to sample per file
  per_sample <- ceiling(num_cells/length(files))

  # Sample equal number of cells from each sample
  all_inds <- c()
  for (file in files) {
    # Get all cells belonging to current sample
    sample_cells <- cells_of_interest %>%
      tidytable::filter(.id == file) %>%
      tidytable::pull(cell_id)

    # Sample cells and subset table
    inds <- sample(x = sample_cells, size = per_sample)
    all_inds <- c(all_inds, inds)
  }

  # Select sampled rows from data table
  agg <- cells_of_interest %>%
    tidytable::filter(cell_id %in% all_inds)

  # write clusters to original .fcs files? `agg_name` not used

  return(agg)
}


#' clusterSubset
#'
#' consider deleting this one !!!
#'
#' @param aggregate An aggregated .fcs file, as generated by [createFilteredAggregate()].
#' @param fsom_name A string to name the resulting FlowSOM object.
#' @param markers_to_cluster A character vector of the markers you would like to
#' use for reclustering.
#' @param num_clus The number of metaclusters you would like.
#'
#' @details
#' This function may be used if you wish to select the markers to use for
#' clustering yourself, rather than use PCA. It takes in an aggregate .fcs file,
#' and clusters the cells within it using the specified markers of interest.
#'
#' The resulting FlowSOM object will be saved to the directory defined in
#' \code{dir_rds_unedit()} with the name specified by \code{fsom_name}.
#'
#' @return A FlowSOM object as generated by \code{\link[FlowSOM:FlowSOM]{FlowSOM()}}.
#'
#' @export
clusterSubset <- function(aggregate, fsom_name, markers_to_cluster, num_clus) {

  fsom_subset <- FlowSOM::FlowSOM(aggregate,
                                 colsToUse = markers_to_cluster,
                                 nClus = num_clus,
                                 xdim = 10,
                                 ydim = 10,
                                 seed = 42)

  saveRDS(fsom_subset, paste0(dir_rds_unedited, fsom_name, ".rds"))

  return(fsom_subset)
}


#' doPCA
#'
#' Performs PCA on a data.frame or a flowFrame's data matrix.
#'
#' @param input A data frame.
#' @param cols_to_use Columns of the input to use for PCA.
#'
#' @return A prcomp object.
#'
#' @export
doPCA <- function(input, cols_to_use) {
  result <- UseMethod("doPCA")
  return(result)
}

#' doPCA.flowFrame
#'
#' Performs PCA on an aggregate .fcs file's data matrix.
#'
#' @keywords internal
#' @export
doPCA.flowFrame <- function(input, cols_to_use) {
  if (!is.numeric(cols_to_use)) {
    marker_inds <- which(Biobase::pData(flowCore::parameters(input))$desc %in% cols_to_use)
    channel_inds <- which(Biobase::pData(flowCore::parameters(input))$name %in% cols_to_use)
    if (length(marker_inds) > 0) {
      cols_to_use <- marker_inds
    } else if (length(channel_inds) > 0) {
      cols_to_use <- channel_inds
    }
  }
  #dat <- input[,which(Biobase::pData(flowCore::parameters(input))$desc %in% cols_to_use)]
  dat <- flowCore::exprs(input)[, cols_to_use]
  pca <- stats::prcomp(dat)
  return(pca)
}

#' doPCA.data.frame
#'
#' Performs PCA on a data frame.
#'
#' @keywords internal
#' @export
doPCA.data.frame <- function(input, cols_to_use) {
  expr_data <- input %>%
    tidytable::select(cols_to_use)

  pca <- stats::prcomp(expr_data)
  return(pca)
}


#' plotPCAScree
#'
#' Plot a scree plot for an aggregate .fcs file's principal components.
#'
#' @param pca_obj A \code{\link[stats]{prcomp}} object as generated by [doPCA()].
#'
#' @details
#' This function produces a scree plot, which may be used to determine which principal
#' components should be used in the analysis. Typically, there is a distinct
#' "elbow" in the plot, where the amount of variance explained by each component
#' becomes drastically smaller. So, if this elbow appears at principal component
#' 5, you would use components 1-5 to recluster your data. If there is no
#' obvious elbow, it is instead reasonable to use whichever number of components
#' explains roughly 80% of the variance.
#'
#' @return A scree plot generated with \code{\link[ggplot2]{ggplot2}}.
#'
#' @export
plotPCAScree <- function(pca_obj) {
  # Calculate variance explained by each principal component
  df <- data.frame(var_explained = pca_obj$sdev^2/sum(pca_obj$sdev^2),
                   m = c(1:length(pca_obj$sdev)))

  # Scree plot
  p <- ggplot2::ggplot(df, ggplot2::aes(x = df$m, y = df$var_explained)) +
    ggplot2::geom_point() +
    ggplot2::geom_line() +
    ggplot2::labs(x = "M", y = "Variance Explained", title = "Scree Plot") +
    ggplot2::scale_x_continuous(breaks = seq(1, length(pca_obj$sdev), 1))

  return(p)
}


#' revertPCAFlowSOM
#'
#' Reverts elements of a FlowSOM object generated on principal components back
#' to channels.
#'
#' @param fsom A FlowSOM object as generated by [clusterSubsetWithPCA()].
#' @param aggregate The aggregate .fcs file used to generate the given FlowSOM
#' object.
#' @param pca_obj A \code{\link[stats]{prcomp}} object as generated by [doPCA()]
#' @param num_components The number of principal components to use for reclustering,
#' as determined by examining results of [plotPCAScree()].
#'
#' @details
#' This function converts a FlowSOM object created from principal components,
#' as generated by \code{clusterSubsetWithPCA()}, into an
#' equivalent FlowSOM object defined in terms of channels instead. The
#' cluster/metacluster assignments for each cell remains the same, but the
#' resulting FlowSOM object is able to be used with built-in FlowSOM functions
#' like \code{PlotStars}, \code{PlotPies}, etc. Therefore other flowFun functions
#' like \code{plotLabeled2DScatter} and \code{searchByExpression} also work on
#' the resulting object.
#'
#' @keywords internal
#'
#' @return A FlowSOM object defined in terms of channels.
#'
revertPCAFlowSOM <- function(fsom, aggregate, pca_obj, num_components) {
  fsom$data <- flowCore::exprs(aggregate)
  mcl <- node <- NULL

  # metaclusterMFIs
  fsom$map$metaclusterMFIs <- data.frame(flowCore::exprs(aggregate),
                                        mcl = fsom$metaclustering[fsom$map$mapping[, 1]],
                                        check.names = FALSE) %>%
    dplyr::group_by(mcl, .drop = FALSE) %>%
    dplyr::summarise_all(stats::median) %>%
    dplyr::select(-mcl) %>%
    data.frame(row.names = levels(fsom$metaclustering),
               check.names = FALSE)

  # Data frame grouped by cluster
  node_df <- data.frame(fsom$data,
                        node = fsom$map$mapping[, 1],
                        check.names = FALSE) %>%
    dplyr::group_by(node, .drop = FALSE)

  # Helper to calculate CV values
  cv_fun <- function(dat) {
    stats::sd(dat)/mean(dat)
  }

  # Put necessary functions in a list to iterate over
  functions <- c(stats::median, stats::sd, stats::mad, cv_fun)
  names(functions) <- c("medianValues", "sdValues", "madValues", "cvValues")

  # Calculate new summary statistics for each cluster
  for (i in 1:length(functions)) {
    fsom$map[[names(functions)[i]]] <- node_df %>%
      dplyr::summarise_all(functions[i]) %>%
      dplyr::select(-node) %>%
      data.frame(row.names = 1:fsom$map$nNodes,
                 check.names = FALSE)
    colnames(fsom$map[[names(functions)[i]]]) <- sub(paste0("_", names(functions)[i]),
                                                    "",
                                                    colnames(fsom$map[[names(functions)[i]]]))
    fsom$map[[names(functions)[i]]] <- methods::as(fsom$map[[names(functions)[i]]], "matrix")
  }

  # pctgs
  pctgs <- rep(0, fsom$map$nNodes)
  names(pctgs) <- as.character(seq_len(fsom$map$nNodes))
  pctgs_tmp <- table(fsom$map$mapping[, 1]) / nrow(fsom$map$mapping)
  pctgs[names(pctgs_tmp)] <- pctgs_tmp
  fsom$map$pctgs <- pctgs

  # prettyColnames
  all_markers <- Biobase::pData(flowCore::parameters(aggregate))$desc
  all_channels <- Biobase::pData(flowCore::parameters(aggregate))$name
  marker_df <- stats::na.omit(data.frame(marker = all_markers,
                                         channel = all_channels))
  rownames(marker_df) <- NULL

  agg_colnames <- colnames(flowCore::exprs(aggregate))
  new_pretty_colnames <- c()
  for (colname in agg_colnames) {
    if (colname %in% marker_df$channel) {
      ind <- which(marker_df$channel == colname)
      new_pretty_colnames <- c(new_pretty_colnames,
                              paste0(marker_df$marker[ind], " <",
                                     marker_df$channel[ind], ">"))
    } else {
      new_pretty_colnames <- c(new_pretty_colnames,
                              paste0(colname, " <", colname, ">"))
    }
  }
  names(new_pretty_colnames) <- colnames(aggregate)
  fsom$prettyColnames <- new_pretty_colnames

  # colsUsed
  fsom$map$colsUsed <- FlowSOM::GetChannels(fsom, marker_df$marker)

  #codes
  fsom$map$codes <- t(t(fsom$map$codes %*% t(pca_obj$rotation[, 1:num_components])) +
                        pca_obj$center)

  return(fsom)
}


#' clusterSubsetWithPCA
#'
#' Recluster a subset of flow data using principal components of a filtered
#' aggregate .fcs file.
#'
#' @param input An aggregated .fcs file, as generated by [createFilteredAggregate()],
#' or a data frame.
#' @param pca_obj A \code{\link[stats]{prcomp}} object as generated by [doPCA()]
#' @param num_components The number of principal components to use for reclustering,
#' as determined by examining results of [plotPCAScree()].
#' @param num_clus The number of metaclusters you would like.
#' @param xdim x-dimension of the SOM. Default is 10.
#' @param ydim y-dimension of the SOM. Default is 10.
#' @param seed A seed for reproducible results. Default is \code{NULL}.
#' @param convert_to_channels Logical, should the returned FlowSOM object's data
#' be defined in terms of channels. Default is \code{TRUE}.
#'
#' @details
#' When reclustering a subset of flow data, such as a cell population that has
#' been identified as monocytes, not every marker you used for the initial clustering
#' is still relevant. In such a case, you would no longer be interested in using,
#' for instance, a B cell marker. One solution is to leave it up to the
#' researcher to determine what markers are appropriate for the reclustering,
#' but this approach is very user-dependent, therefore lacking reproducibility.
#'
#' This function solves this problem by using PCA for reclustering. It
#' takes in an aggregate .fcs file, as generated by \code{createFilteredAggregate()},
#' and clusters the cells within it using the specified number of principal
#' components. If \code{convert_to_channels} is \code{TRUE} (default), it then
#' takes the cluster and metacluster assignments found from this clustering to
#' create a FlowSOM object defined in terms of channels, rather than
#' principal components, so that it may still be used with both the functions
#' in flowFun and in FlowSOM.
#'
#' @return A FlowSOM object.
#'
#' @export
clusterSubsetWithPCA <- function(input, pca_obj, num_components,
                                 num_clus, xdim = 10, ydim = 10, seed = NULL,
                                 convert_to_channels = TRUE) {
  result <- UseMethod("clusterSubsetWithPCA")
  return(result)
}

#' clusterSubsetWithPCA.FlowSOM
#'
#' Recluster a subset of flow data using principal components of a filtered
#' aggregate .fcs file.
#'
#' @keywords internal
#' @export
clusterSubsetWithPCA.FlowSOM <- function(input, pca_obj, num_components,
                                         num_clus, xdim = 10, ydim = 10, seed = NULL,
                                         convert_to_channels = TRUE) {

  # Select specified principal components
  selected_pca_cols <- pca_obj$x[, 1:num_components]

  # Add file and ID columns to input
  fsom_input <- cbind(selected_pca_cols,
                      flowCore::exprs(input[, c("File", "Original_ID", "Original_ID2")]))

  # New FlowSOM object
  fsom_subset <- FlowSOM::FlowSOM(fsom_input,
                                  colsToUse = colnames(fsom_input[, 1:num_components]),
                                  nClus = num_clus,
                                  xdim = xdim,
                                  ydim = ydim,
                                  seed = seed)

  if (convert_to_channels) {
    fsom_subset <- revertPCAFlowSOM(fsom_subset, input, pca_obj, num_components)
    # fsom_subset$map$codes <- t(t(fsom_subset$map$codes %*% t(pca_obj$rotation[,1:num_components])) +
    #                              pca_obj$center)
  }

  # saveRDS(fsom_subset, paste0(dir_rds_unedited(), fsom_name, ".rds"))

  return(fsom_subset)
}

#' clusterSubsetWithPCA.data.frame
#'
#' Recluster a subset of flow data using principal components of a data frame.
#'
#' @keywords internal
#' @export
clusterSubsetWithPCA.data.frame <- function(input, pca_obj, num_components,
                                           num_clus, xdim = 10, ydim = 10, seed = NULL,
                                           convert_to_channels = TRUE) {
  .id <- cell_id <- NULL

  # Select specified principal components
  selected_pca_cols <- pca_obj$x[, 1:num_components]

  fsom_input <- as.matrix(selected_pca_cols)
  rownames(fsom_input) <- input$cell_id

  # New FlowSOM object
  fsom_subset <- FlowSOM::FlowSOM(fsom_input,
                                  colsToUse = colnames(fsom_input[, 1:num_components]),
                                  nClus = num_clus,
                                  xdim = xdim,
                                  ydim = ydim,
                                  seed = seed)

  metaclusters <- FlowSOM::GetMetaclusters(fsom_subset)
  clusters <- FlowSOM::GetClusters(fsom_subset)

  fsom_table <- input %>%
    tidytable::mutate(Metacluster = metaclusters,
                      Cluster = clusters)

  # if (convert_to_channels) { #`input` was previously flowFrame
  #   fsom_subset <- revertPCAFlowSOM(fsom_subset, original_data, pca_obj, num_components)
  # }

  # saveRDS(fsom_subset, paste0(dir_rds_unedited(), "new_fsom.rds")) # make optional

  return(fsom_table)
}

#' editFlowSOMMetaData
#'
#' @param fsom A FlowSOM object to annotate.
#' @param metadata A named list of metadata to add to the FlowSOM object.
#' @param clear Boolean, should the existing metadata be cleared before editing.
#'
#' @details
#' It is useful to keep track of:
#'  - aggregate file used for clustering
#'    - number of cells aggregated
#'    - which files were used and in what order they were read
#'  - which directory contains the clustered files resulting from the FlowSOM object
#'  - any parent FlowSOM objects, if current FlowSOM object is a reclustering
#'
#' @keywords internal
#'
#' @return A FlowSOM object with edited metadata.
#'
#' @export
editFlowSOMMetaData <- function(fsom, metadata, clear = NULL) {
  if (!inherits(fsom, "FlowSOM")) {
    stop("fsom must be a FlowSOM object.")
  }

  if (clear) {
    fsom$metaData <- NULL
  }

  for (name in names(metadata)) {
    fsom$metaData[[name]] <- metadata[[name]]
  }

  return(fsom)
}

#' setupDirectories
#'
#' !!! edit !!! Initializes and creates all directories necessary for the pipeline.
#'
#' @param dirs_custom A named list specifying any custom directory names.
#'
#' @details
#' By default, this function creates a directory structure as follows:
#'
#' - \code{getwd()}
#'   - Data
#'     - SetUp (\code{dir_setup})
#'     - Preprocessed SetUp (\code{dir_setup_prepr})
#'     - Raw (\code{dir_raw})
#'     - Preprocessed Files (\code{dir_prepr})
#'     - Aggregates (\code{dir_agg})
#'     - Clustered Files (\code{dir_clustr})
#'   - Info
#'   - RDS (\code{dir_rds})
#'     - Unedited (\code{dir_rds_unedited})
#'     - Edited (\code{dir_rds_edited})
#'   - Preprocessing Results
#'     - QC plots
#'   - Analysis Results
#'     - limma Analysis
#'     - edgeR Analysis
#'
#' @export
#'
#' @examples
#' setupDirectories(list(dir_prepr = file.path("Data", "Preprocessed Files Batch1")))
setupDirectories = function(dirs_custom = list()) {

  # Reassign environment variables if necessary
  if ("dir_rds" %in% names(dirs_custom)) {
    set_dir_rds(dirs_custom$dir_rds)
  }
  if ("dir_rds_unedited" %in% names(dirs_custom)) {
    set_dir_rds_unedited(dirs_custom$dir_rds_unedited)
  }
  if ("dir_rds_edited" %in% names(dirs_custom)) {
    set_dir_rds_edited(dirs_custom$dir_rds_edited)
  }
  if ("dir_agg" %in% names(dirs_custom)) {
    set_dir_agg(dirs_custom$dir_agg)
  }
  if ("dir_result" %in% names(dirs_custom)) {
    set_dir_result(dirs_custom$dir_result)
  }
  if ("dir_prepr" %in% names(dirs_custom)) {
    set_dir_prepr(dirs_custom$dir_prepr)
  }
  if ("dir_clustr" %in% names(dirs_custom)) {
    set_dir_clustr(dirs_custom$dir_clustr)
  }

  # Create a vector of all directory names in the environment
  dir_names <- c(dir_rds(), dir_rds_unedited(), dir_rds_edited(),
                 dir_agg(), dir_result(), dir_prepr(), dir_clustr())

  # Create each directory if it does not already exist
  for (dir in dir_names) {
    if (!dir.exists(dir)) {
      dir.create(dir, recursive = TRUE)
    }
  }
}
