#' addMetadataToFlowSOM
#'
#' @param fsom A FlowSOM object as generated by the FlowSOM function.
#' @param aggregate The aggregate file used to create the given FlowSOM object.
#'
#' @return A FlowSOM object with added metadata.
#'
#' @export
addMetadataToFlowSOM = function(fsom, aggregate) {
  if (!inherits(fsom, "FlowSOM")) {
    stop("fsom must be a FlowSOM object.")
  }

  fsom$metadata <- list(
    aggregate_file <- aggregate@description$FILENAME
    # preprocessed_files_dir <- dir_prepr
  )

  return(fsom)
}

#' filterFCS
#'
#' @param ff A flowFrame.
#' @param clusters A character vector specifying which clusters to keep. Default
#' is \code{NULL}.
#' @param metaclusters A character vector specifying which metaclusters to keep.
#' Default is \code{NULL}.
#'
#' @return A flowFrame, where only cells belonging to the given clusters or
#' metaclusters are included.
#'
#' @export
filterFCS = function(ff, clusters = NULL, metaclusters = NULL) {
  filter_clust = flowCore::exprs(ff)[,"FlowSOM_cluster"] %in% clusters
  filter_meta = flowCore::exprs(ff)[,"FlowSOM_meta"] %in% metaclusters
  filter = which(filter_clust | filter_meta)

  filtered = ff[filter]
  return(filtered)
}

#' createFilteredAggregate
#'
#' Filter preprocessed .fcs files to create a new aggregate file
#'
#' @param fsom A FlowSOM object as generated by the FlowSOM function.
#' @param num_cells The total number of cells to include in the aggregate file.
#' @param clusters A numeric vector listing the clusters of interest.
#' @param metaclusters A character vector listing the metaclusters of interest.
#' @param agg_name An .fcs filename. Default is "filtered_aggregate.fcs".
#' @param dir_save If a directory path is given, then the filtered .fcs
#' files used to create the aggregate file will be saved there. If \code{NULL}
#' (default), then they will be discarded.
#'
#' @details
#' It is only necessary to define one of the arguments \code{clusters} and
#' \code{metaclusters}, but the user may use both if they wish.
#'
#' This function takes in a group of clustered .fcs files, as generated
#' by \code{FlowSOM::SaveClustersToFCS}, and subsets them to create a new set of
#' .fcs files that contain only the cells included in the given metaclusters
#' and/or clusters. If desired, these new .fcs files are then written to a new
#' directory, whose name is specified by the user with the \code{dir_save}
#' parameter. Note that it is only necessary to save the files if you intend to perform
#' additional reclustering on them, otherwise they may be safely deleted. The
#' aggregate file is written to the directory saved in \code{dir_agg()} under the
#' name specified by \code{agg_name}.
#'
#' @return An aggregated flowFrame, where only cells belonging to the given
#' metaclusters and/or clusters are included.
#'
#' @export
createFilteredAggregate = function(fsom, num_cells, clusters = NULL,
                                   metaclusters = NULL,
                                   agg_name = "filtered_aggregate.fcs",
                                   dir_save = NULL) {
  print(paste0("Creating aggregate with files from directory ", dir_clustr(), "..."))

  metaclusters = which(levels(fsom$metaclustering) == metaclusters)

  frames = lapply(list.files(dir_clustr(), full.names = TRUE), flowCore::read.FCS)

  filtered_frames = lapply(frames, filterFCS, clusters, metaclusters)

  if (!is.null(dir_save) && !dir.exists(dir_save)) {
    dir.create(dir_save)

    names(filtered_frames) = paste0(dir_save, list.files(dir_prepr()))

    for (i in 1:length(filtered_frames)) {
      flowCore::write.FCS(x = methods::as(filtered_frames[[i]], "flowFrame"),
                          filename = names(filtered_frames)[i])
    }
  }

  filtered_fs = methods::as(filtered_frames, "flowSet")

  agg = FlowSOM::AggregateFlowFrames(filtered_fs,
                                     cTotal = num_cells,
                                     writeOutput = TRUE,
                                     outputFile = paste0(dir_agg(), agg_name))
  return(agg)
}

#' clusterSubset
#' 
#' consider deleting this one !!!
#'
#' @param aggregate An aggregated .fcs file, as generated by \code{createFilteredAggregate}.
#' @param fsom_name A string to name the resulting FlowSOM object.
#' @param markers_to_cluster A character vector of the markers you would like to 
#' use for reclustering.
#' @param num_clus The number of metaclusters you would like.
#' 
#' @details
#' clusterSubset() may be used if you wish to select the markers to use for
#' clustering yourself, rather than use PCA. It takes in an aggregate .fcs file,
#' and clusters the cells within it using the specified markers of interest.
#' 
#' The resulting FlowSOM object will be saved to the directory defined in 
#' \code{dir_rds_unedit()} with the name specified by \code{fsom_name}.
#'
#' @return A FlowSOM object as generated by \code{FlowSOM::FlowSOM}.
#' 
#' @export
clusterSubset = function(aggregate, fsom_name, markers_to_cluster, num_clus) {

  fsom_subset = FlowSOM::FlowSOM(aggregate,
                                 colsToUse = markers_to_cluster,
                                 nClus = num_clus,
                                 xdim = 10,
                                 ydim = 10,
                                 seed = 42)

  saveRDS(fsom_subset, paste0(dir_rds_unedited, fsom_name, ".rds"))

  return(fsom_subset)
}

#' doAggregatePCA
#' 
#' Performs PCA on an aggregate .fcs file's data matrix.
#'
#' @param aggregate An aggregate .fcs file as generated by \code{createFilteredAggregate}.
#' @param markers_to_cluster A character vector of the markers you would like to 
#' use for reclustering.
#'
#' @return A list with class \code{prcomp}.
#' 
#' @export
doAggregatePCA = function(aggregate, markers_to_cluster) {
  dat = aggregate[,which(Biobase::pData(flowCore::parameters(aggregate))$desc %in% markers_to_cluster)]
  dat = flowCore::exprs(dat)
  pca = stats::prcomp(dat)
  return(pca)
}

#' plotPCAScree
#' 
#' Plot a scree plot for an aggregate .fcs file's principal components.
#'
#' @param pca_obj A \code{prcomp} object as generated by \code{doAggregatePCA}.
#'
#' @details
#' This function produces a scree plot, which may be used to determine which principal
#' components should be used in the analysis. Typically, there is a distinct
#' "elbow" in the plot, where the amount of variance explained by each component
#' becomes drastically smaller. So, if this elbow appears at principal component
#' 5, you would use components 1-5 to recluster your data. If there is no
#' obvious elbow, it is instead reasonable to use whichever number of components
#' explains roughly 80% of the variance.
#' 
#' @return A scree plot generated by \code{ggplot2}.
#' 
#' @export
plotPCAScree = function(pca_obj) {
  df = data.frame(var_explained = pca_obj$sdev^2/sum(pca_obj$sdev^2),
                  m = c(1:length(pca_obj$sdev)))
  
  p = ggplot2::ggplot(df, ggplot2::aes(x = df$m, y = df$var_explained)) + 
    ggplot2::geom_point() + 
    ggplot2::geom_line() +
    ggplot2::labs(x = "M", y = "Variance Explained", title = "Scree Plot") +
    ggplot2::scale_x_continuous(breaks = seq(1, length(pca_obj$sdev), 1))
  
  return(p)
}

#' revertPCAFlowSOM
#' 
#' Reverts elements of a FlowSOM object generated on principal components back
#' to channels.
#'
#' @param fsom A FlowSOM object as generated by \code{clusterSubsetWithPCA}.
#' @param aggregate The aggregate .fcs file used to generate the given FlowSOM 
#' object.
#' 
#' @details
#' This function converts a FlowSOM object created from principal components,
#' as generated by \code{clusterSubsetWithPCA}, into an
#' equivalent FlowSOM object defined in terms of channels instead. The
#' cluster/metacluster assignments for each cell remains the same, but the
#' resulting FlowSOM object is able to be used with built-in FlowSOM functions
#' like \code{FlowSOM::PlotStars}, \code{FlowSOM::PlotPies}, etc. 
#' Therefore other flowFun functions like \code{plotLabeled2DScatter} and 
#' \code{searchByExpression} also work on the resulting object.
#'
#' @return A FlowSOM object defined in terms of channels.
#' 
#' @export
revertPCAFlowSOM = function(fsom, aggregate) {
  fsom$data = flowCore::exprs(aggregate)
  dir_prepr = dir_prepr()
  mcl <- node <- NULL
  
  # metaclusterMFIs
  fsom$map$metaclusterMFIs = data.frame(flowCore::exprs(aggregate),
                                        mcl = fsom$metaclustering[fsom$map$mapping[, 1]],
                                        check.names = FALSE) %>%
    dplyr::group_by(mcl, .drop = FALSE) %>%
    dplyr::summarise_all(stats::median) %>%
    dplyr::select(-mcl) %>%
    data.frame(row.names = levels(fsom$metaclustering),
               check.names = FALSE)
  
  
  node_df = data.frame(fsom$data,
                       node = fsom$map$mapping[, 1],
                       check.names = FALSE) %>%
    dplyr::group_by(node, .drop = FALSE)
  
  cv_fun = function(dat) {
    stats::sd(dat)/mean(dat)
  }
  
  functions = c(stats::median, stats::sd, stats::mad, cv_fun)
  names(functions) = c("medianValues", "sdValues", "madValues", "cvValues")
  
  for (i in 1:length(functions)) {
    fsom$map[[names(functions)[i]]] = node_df %>%
      dplyr::summarise_all(functions[i]) %>%
      dplyr::select(-node) %>%
      data.frame(row.names = 1:fsom$map$nNodes,
                 check.names = FALSE)
    colnames(fsom$map[[names(functions)[i]]]) = sub(paste0("_", names(functions)[i]),
                                                    "",
                                                    colnames(fsom$map[[names(functions)[i]]]))
    fsom$map[[names(functions)[i]]] = methods::as(fsom$map[[names(functions)[i]]], "matrix")
  }
  
  # pctgs
  pctgs = rep(0, fsom$map$nNodes)
  names(pctgs) = as.character(seq_len(fsom$map$nNodes))
  pctgs_tmp = table(fsom$map$mapping[, 1]) / nrow(fsom$map$mapping)
  pctgs[names(pctgs_tmp)] = pctgs_tmp
  fsom$map$pctgs = pctgs
  
  # prettyColnames
  filename = list.files(dir_prepr, full.names = TRUE)[1]
  ff = flowCore::read.FCS(filename)
  all_markers = Biobase::pData(flowCore::parameters(ff))$desc
  all_channels = Biobase::pData(flowCore::parameters(ff))$name
  marker_df = stats::na.omit(data.frame(marker = all_markers,
                                        channel = all_channels))
  rownames(marker_df) = NULL
  
  agg_colnames = colnames(flowCore::exprs(aggregate))
  new_pretty_colnames = c()
  for (colname in agg_colnames) {
    if (colname %in% marker_df$channel) {
      ind = which(marker_df$channel == colname)
      new_pretty_colnames = c(new_pretty_colnames,
                              paste0(marker_df$marker[ind], " <",
                                     marker_df$channel[ind], ">"))
    } else {
      new_pretty_colnames = c(new_pretty_colnames,
                              paste0(colname, " <", colname, ">"))
    }
  }
  names(new_pretty_colnames) = colnames(aggregate)
  fsom$prettyColnames = new_pretty_colnames
  
  # colsUsed
  fsom$map$colsUsed = FlowSOM::GetChannels(fsom, marker_df$marker)
  
  return(fsom)
}